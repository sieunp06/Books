# Item 4 인스턴스화를 막으려거든 private 생성자를 사용하라.
### content
- [정적 메서드와 정적 필드만을 담은 클래스](#정적-메서드와-정적-필드만을-담은-클래스)
- [인스턴스화를 막으려면?](#인스턴스화를-막으려면)
    - [❓ 생성자를 명시하지 않으면?](#-생성자를-명시하지-않으면)
    - [❓ 추상 클래스로 만들면?](#-추상-클래스로-만들면)
- [private 생성자를 사용하라.](#private-생성자를-사용하라)

---
## 정적 메서드와 정적 필드만을 담은 클래스
> 정적 메서드와 정적 필드만을 담은 클래스는 나름의 쓰임새가 있다.

정적 메서드와 정적 필드만을 담은 클래스는 다음과 같다.
- 기본 타입 값이나 배열 관련 메서드를 모은 클래스
  - `java.lang.Math`
  - `java.util.Arrays`
    ```java
    public class Arrays {
        public static boolean isArray(Object o) { ...}

        public static Object[] asObjectArray(Object array) { ...}

        // ...

        private Arrays() {
        }
    }
    ```
    - 모든 메서드가 `static`으로 선언되어 있고, 생성자가 `private`으로 선언되어 있다.
- 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메소드(or 팩토리)를 모은 클래스
  - `java.util.Collections`
    - 모든 메서드가 `static`으로 선언되어 있고, 생성자가 `private`으로 선언되어 있다.
- final 클래스와 관련된 메소드들을 모아놓을 때 
  - `String` 클래스

## 인스턴스화를 막으려면?
위와 같은 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아니다.

### ❓ 생성자를 명시하지 않으면?
생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다.

즉, 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동 생성된 것인지 알 수 없다.

### ❓ 추상 클래스로 만들면?
`abstract`는 보통 상속해서 쓰라는 의미로 많이 사용한다.

때문에 하위 클래스를 생성하면 인스턴스화가 가능해진다.

## private 생성자를 사용하라.
컴파일러가 기본 생성자를 만드는 경우는 오직 명시된 생성자가 없을 때 뿐이니 `private` 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

```java
public class UtilityClass {
    private UtilityClass() {
        throw new AssertionError();
    }
}
```

위와 같이 굳이 에러를 던질 필요는 없지만, 클래스 안에서 실수로 생성자를 호출하는 실수를 방지해준다.